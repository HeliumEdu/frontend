// Copyright (c) 2025 Helium Edu
//
// This source code is licensed under the MIT license found in the
// LICENSE file in the root directory of this source tree.
//
// For details regarding the license, please refer to the LICENSE file.

import 'package:flutter/material.dart';
import 'package:heliumapp/data/models/planner/course_model.dart';
import 'package:heliumapp/data/models/planner/course_schedule_event_model.dart';
import 'package:heliumapp/data/models/planner/course_schedule_model.dart';
import 'package:logging/logging.dart';

final _log = Logger('data.sources');

/// Builds course schedule events from local course data without hitting the API.
///
/// This source generates [CourseScheduleEventModel] instances by expanding
/// the recurrence rules in [CourseScheduleModel] for a given date range.
class CourseScheduleBuilderSource {
  /// Builds course schedule events for the given courses within the date range.
  ///
  /// Events are generated by expanding each course's schedule rules (days of week,
  /// start/end times) for dates between [from] and [to], bounded by each course's
  /// start and end dates.
  ///
  /// If [search] is provided, only events whose title contains the search string
  /// (case-insensitive) are returned.
  List<CourseScheduleEventModel> buildCourseScheduleEvents({
    required List<CourseModel> courses,
    required DateTime from,
    required DateTime to,
    String? search,
    bool? shownOnCalendar,
  }) {
    _log.info('Building CourseScheduleEvents for ${courses.length} course(s)');

    final List<CourseScheduleEventModel> events = [];

    for (final course in courses) {
      for (final schedule in course.schedules) {
        final scheduleEvents = _buildEventsForSchedule(
          course: course,
          schedule: schedule,
          from: from,
          to: to,
        );
        events.addAll(scheduleEvents);
      }
    }

    // Apply search filter if provided
    List<CourseScheduleEventModel> filteredEvents = events;
    if (search != null && search.isNotEmpty) {
      final searchLower = search.toLowerCase();
      filteredEvents = events
          .where((event) => event.title.toLowerCase().contains(searchLower))
          .toList();
    }

    // Sort by start time
    filteredEvents.sort((a, b) => a.start.compareTo(b.start));

    _log.info('... built ${filteredEvents.length} CourseScheduleEvent(s)');
    return filteredEvents;
  }

  /// Builds events for a single schedule within the date range.
  List<CourseScheduleEventModel> _buildEventsForSchedule({
    required CourseModel course,
    required CourseScheduleModel schedule,
    required DateTime from,
    required DateTime to,
  }) {
    final List<CourseScheduleEventModel> events = [];

    // Determine effective date range (intersection of requested range and course dates)
    final effectiveStart = _maxDate(from, course.startDate);
    final effectiveEnd = _minDate(to, course.endDate);

    // If no overlap, return empty
    if (effectiveStart.isAfter(effectiveEnd)) {
      return events;
    }

    // Iterate through each day in the range
    DateTime currentDate = _dateOnly(effectiveStart);
    final endDate = _dateOnly(effectiveEnd);

    while (!currentDate.isAfter(endDate)) {
      final dayIndex = _getDayIndex(currentDate);

      // Check if this day is active in the schedule
      if (_isDayActive(schedule.daysOfWeek, dayIndex)) {
        final event = _createEventForDay(
          course: course,
          schedule: schedule,
          date: currentDate,
          dayIndex: dayIndex,
        );
        events.add(event);
      }

      currentDate = currentDate.add(const Duration(days: 1));
    }

    return events;
  }

  /// Creates a single event for a specific day.
  CourseScheduleEventModel _createEventForDay({
    required CourseModel course,
    required CourseScheduleModel schedule,
    required DateTime date,
    required int dayIndex,
  }) {
    final startTime = _getStartTimeForDayIndex(schedule, dayIndex);
    final endTime = _getEndTimeForDayIndex(schedule, dayIndex);

    final start = DateTime(
      date.year,
      date.month,
      date.day,
      startTime.hour,
      startTime.minute,
    );
    final end = DateTime(
      date.year,
      date.month,
      date.day,
      endTime.hour,
      endTime.minute,
    );

    // Generate a deterministic ID based on schedule ID and date
    final eventId = _generateEventId(schedule.id, date);

    return CourseScheduleEventModel(
      id: eventId,
      title: course.title,
      allDay: false,
      showEndTime: true,
      start: start,
      end: end,
      priority: 50,
      url: null,
      comments: '',
      attachments: [],
      reminders: [],
      color: course.color,
      ownerId: 'course-${course.id}',
    );
  }

  /// Generates a deterministic event ID from schedule ID and date.
  ///
  /// Uses a simple hash combining schedule ID with the date's days since epoch.
  /// This ensures the same event always gets the same ID.
  int _generateEventId(int scheduleId, DateTime date) {
    final daysSinceEpoch = date.difference(DateTime(1970, 1, 1)).inDays;
    // Combine schedule ID and date into a unique ID
    // Using a large prime to reduce collisions
    return scheduleId * 100000 + daysSinceEpoch;
  }

  /// Converts Dart's DateTime.weekday (1=Monday, 7=Sunday) to our index (0=Sunday, 6=Saturday).
  int _getDayIndex(DateTime date) {
    // DateTime.weekday: 1=Mon, 2=Tue, 3=Wed, 4=Thu, 5=Fri, 6=Sat, 7=Sun
    // Our index: 0=Sun, 1=Mon, 2=Tue, 3=Wed, 4=Thu, 5=Fri, 6=Sat
    return date.weekday == 7 ? 0 : date.weekday;
  }

  /// Checks if the given day index is active in the daysOfWeek string.
  bool _isDayActive(String daysOfWeek, int dayIndex) {
    if (dayIndex < 0 || dayIndex >= daysOfWeek.length) {
      return false;
    }
    return daysOfWeek[dayIndex] == '1';
  }

  /// Gets the start time for a specific day index.
  TimeOfDay _getStartTimeForDayIndex(
    CourseScheduleModel schedule,
    int dayIndex,
  ) {
    switch (dayIndex) {
      case 0:
        return schedule.sunStartTime;
      case 1:
        return schedule.monStartTime;
      case 2:
        return schedule.tueStartTime;
      case 3:
        return schedule.wedStartTime;
      case 4:
        return schedule.thuStartTime;
      case 5:
        return schedule.friStartTime;
      case 6:
        return schedule.satStartTime;
      default:
        return schedule.sunStartTime;
    }
  }

  /// Gets the end time for a specific day index.
  TimeOfDay _getEndTimeForDayIndex(CourseScheduleModel schedule, int dayIndex) {
    switch (dayIndex) {
      case 0:
        return schedule.sunEndTime;
      case 1:
        return schedule.monEndTime;
      case 2:
        return schedule.tueEndTime;
      case 3:
        return schedule.wedEndTime;
      case 4:
        return schedule.thuEndTime;
      case 5:
        return schedule.friEndTime;
      case 6:
        return schedule.satEndTime;
      default:
        return schedule.sunEndTime;
    }
  }

  /// Returns the later of two dates.
  DateTime _maxDate(DateTime a, DateTime b) {
    return a.isAfter(b) ? a : b;
  }

  /// Returns the earlier of two dates.
  DateTime _minDate(DateTime a, DateTime b) {
    return a.isBefore(b) ? a : b;
  }

  /// Returns a DateTime with only the date part (no time).
  DateTime _dateOnly(DateTime date) {
    return DateTime(date.year, date.month, date.day);
  }
}
